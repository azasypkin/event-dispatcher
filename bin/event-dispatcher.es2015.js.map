{"version":3,"sources":["webpack:///webpack/bootstrap 8ee9afca4f81fd793bb7","webpack:///./src/event-dispatcher.js"],"names":["assertValidEventName","eventName","Error","assertValidHandler","handler","assertAllowedEventName","allowedEvents","indexOf","p","Object","freeze","Symbol","listeners","EventDispatcher","Array","isArray","Map","handlers","get","Set","set","add","once","parameters","off","call","on","delete","size","clear","forEach","error","console","has","target","dispatcher","method","bind"],"mappings":"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","file":"event-dispatcher.es2015.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8ee9afca4f81fd793bb7","'use strict';\n\nconst assertValidEventName = function(eventName) {\n  if (!eventName || typeof eventName !== 'string') {\n    throw new Error('Event name should be a valid non-empty string!');\n  }\n};\n\nconst assertValidHandler = function(handler) {\n  if (typeof handler !== 'function') {\n    throw new Error('Handler should be a function!');\n  }\n};\n\nconst assertAllowedEventName = function(allowedEvents, eventName) {\n  if (allowedEvents && allowedEvents.indexOf(eventName) < 0) {\n    throw new Error(`Event \"${eventName}\" is not allowed!`);\n  }\n};\n\nconst p = Object.freeze({\n  allowedEvents: Symbol('allowedEvents'),\n  listeners: Symbol('listeners')\n});\n\nexport default class EventDispatcher {\n  constructor(allowedEvents) {\n    if (typeof allowedEvents !== 'undefined' && !Array.isArray(allowedEvents)) {\n      throw new Error('Allowed events should be a valid array of strings!');\n    }\n\n    this[p.listeners] = new Map();\n    this[p.allowedEvents] = allowedEvents;\n  }\n\n  /**\n   * Registers listener function to be executed once event occurs.\n   *\n   * @param {string} eventName Name of the event to listen for.\n   * @param {function} handler Handler to be executed once event occurs.\n   */\n  on(eventName, handler) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n    assertValidHandler(handler);\n\n    let handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      handlers = new Set();\n      this[p.listeners].set(eventName, handlers);\n    }\n\n    // Set.add ignores handler if it has been already registered.\n    handlers.add(handler);\n  }\n\n  /**\n   * Registers listener function to be executed only first time when event\n   * occurs.\n   *\n   * @param {string} eventName Name of the event to listen for.\n   * @param {function} handler Handler to be executed once event occurs.\n   */\n  once(eventName, handler) {\n    assertValidHandler(handler);\n\n    const once = (parameters) => {\n      this.off(eventName, once);\n\n      handler.call(this, parameters);\n    };\n\n    this.on(eventName, once);\n  }\n\n  /**\n   * Removes registered listener for the specified event.\n   *\n   * @param {string} eventName Name of the event to remove listener for.\n   * @param {function} handler Handler to remove, so it won't be executed\n   * next time event occurs.\n   */\n  off(eventName, handler) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n    assertValidHandler(handler);\n\n    const handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      return;\n    }\n\n    handlers.delete(handler);\n\n    if (!handlers.size) {\n      this[p.listeners].delete(eventName);\n    }\n  }\n\n  /**\n   * Removes all registered listeners for the specified event.\n   *\n   * @param {string=} eventName Name of the event to remove all listeners for.\n   */\n  offAll(eventName) {\n    if (typeof eventName === 'undefined') {\n      this[p.listeners].clear();\n      return;\n    }\n\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n\n    const handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      return;\n    }\n\n    handlers.clear();\n\n    this[p.listeners].delete(eventName);\n  }\n\n  /**\n   * Emits specified event so that all registered handlers will be called\n   * with the specified parameters.\n   *\n   * @param {string} eventName Name of the event to call handlers for.\n   * @param {Object=} parameters Optional parameters that will be passed to\n   * every registered handler.\n   */\n  emit(eventName, parameters) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n\n    const handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      return;\n    }\n\n    handlers.forEach((handler) => {\n      try {\n        handler.call(this, parameters);\n      } catch (error) {\n        console.error(error);\n      }\n    });\n  }\n\n  /**\n   * Checks if there are any listeners that listen for the specified event.\n   *\n   * @param {string} eventName Name of the event to check listeners for.\n   * @returns {boolean}\n   */\n  hasListeners(eventName) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n\n    return this[p.listeners].has(eventName);\n  }\n\n  /**\n   * Mixes dispatcher methods into target object.\n   * @param {Object} target Object to mix dispatcher methods into.\n   * @param {Array.<string>?} allowedEvents Optional list of the allowed event\n   * names that can be emitted and listened for.\n   * @returns {Object} Target object with added dispatcher methods.\n   */\n  static mixin(target, allowedEvents) {\n    if (!target || typeof target !== 'object') {\n      throw new Error('Object to mix into should be valid object!');\n    }\n\n    if (typeof allowedEvents !== 'undefined' && !Array.isArray(allowedEvents)) {\n      throw new Error('Allowed events should be a valid array of strings!');\n    }\n\n    const dispatcher = new EventDispatcher(allowedEvents);\n    ['on', 'once', 'off', 'offAll', 'emit', 'hasListeners'].forEach((method) => {\n      if (typeof target[method] !== 'undefined') {\n        throw new Error(`Object to mix into already has \"${method}\" property defined!`);\n      }\n\n      if (method !== 'constructor') {\n        target[method] = dispatcher[method].bind(dispatcher);\n      }\n    }, dispatcher);\n\n    return target;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/event-dispatcher.js"],"sourceRoot":""}